## Testing and Selection Sort 测试和选择排序

One of the most important skills an intermediate to advanced programmer can have is the ability to tell when your code is correct. In this chapter, we'll discuss how you can write tests to evaluate code correctness. Along the way, we'll also discuss an algorithm for sorting called Selection Sort.  
中高级程序员可以拥有的最重要的技能之一是判断代码何时正确的能力。在本章中，我们将讨论如何编写测试来评估代码的正确性。在此过程中，我们还将讨论一种称为选择排序的排序算法。

### A New Way 一种新方式

<iframe frameborder="0" allowfullscreen="" src="//www.youtube.com/embed/wSuZmP-WE44" data-immersive-translate-effect="1"></iframe>

When you write a program, it may have errors. In a classroom setting, you gain confidence in your code's correctness through some combination of user interaction, code analysis, and autograder testing, with this last item being of the greatest importance in many cases, particularly as it is how you earn points.  
当您编写程序时，它可能会出现错误。在课堂环境中，您可以通过用户交互、代码分析和自动评分器测试的某种组合来获得对代码正确性的信心，最后一项在许多情况下最为重要，尤其是因为它是您获得积分的方式。

Autograders, of course, are not magic. They are code that the instructors write that is fundamentally not all that different from the code that you are writing. In the real world, these tests are written by the programmers themselves, rather than some benevolent Josh-Hug-like third party.  
Autograders，当然，不是魔术。它们是讲师编写的代码，与您编写的代码从根本上没有什么不同。在现实世界中，这些测试是由程序员自己编写的，而不是一些仁慈的 Josh-Hug 之类的第三方。

In this chapter, we'll explore how we can write our own tests. Our goal will be to create a class called `Sort` that provides a method `sort(String[] x)` that destructively sorts the strings in the array `x`.  
在本章中，我们将探讨如何编写自己的测试。我们的目标是创建一个名为 `Sort` 的类，它提供了一个方法 `sort(String[] x)` ，该方法对数组 `x` 中的字符串进行破坏性排序。

As a totally new way of thinking, we'll start by writing `testSort()` first, and only after we've finished the test, we'll move on to writing the actual sorting code.  
作为一种全新的思维方式，我们将首先编写 `testSort()` ，只有在完成测试后，我们才会继续编写实际的排序代码。

### Ad Hoc Testing 临时测试

<iframe frameborder="0" allowfullscreen="" src="//www.youtube.com/embed/Y2_oyfQV52c" data-immersive-translate-effect="1"></iframe>

Writing a test for `Sort.sort` is relatively straightforward, albeit tedious. We simply need to create an input, call `sort`, and check that the output of the method is correct. If the output is not correct, we print out the first mismatch and terminate the test. For example, we might create a test class as follows:  
为 `Sort.sort` 编写测试相对简单，尽管很乏味。我们只需要创建一个输入，调用 `sort` ，并检查该方法的输出是否正确。如果输出不正确，我们打印出第一个不匹配项并终止测试。例如，我们可以创建一个测试类如下：

```
public class TestSort {
    /** Tests the sort method of the Sort class. */
    public static void testSort() {
        String[] input = {"i", "have", "an", "egg"};
        String[] expected = {"an", "egg", "have", "i"};
        Sort.sort(input);
        for (int i = 0; i < input.length; i += 1) {
            if (!input[i].equals(expected[i])) {
                System.out.println("Mismatch in position " + i + ", expected: " + expected + ", but got: " + input[i] + ".");
                break;
            }
        }
    }

    public static void main(String[] args) {
        testSort();
    }
}
```

We can test out our test by creating a blank `Sort.sort` method as shown below:  
我们可以通过创建一个空白的 `Sort.sort` 方法来测试我们的测试，如下所示：

```
public class Sort {
    /** Sorts strings destructively. */
    public static void sort(String[] x) {        
    }
}
```

If we run the `testSort()` method with this blank `Sort.sort` method, we'd get:  
如果我们用这个空白的 `Sort.sort` 方法运行 `testSort()` 方法，我们会得到：

```
Mismatch in position 0, expected: an, but got: i.
```

The fact that we're getting an error message is a good thing! This means our test is working. What's very interesting about this is that we've now created a little game for ourselves to play, where the goal is to modify the code for `Sort.sort` so that this error message no longer occurs. It's a bit of a psychological trick, but many programmers find the creation of these little mini-puzzles for themselves to be almost addictive.  
我们收到错误消息的事实是一件好事！这意味着我们的测试正在运行。非常有趣的是，我们现在已经创建了一个小游戏供我们自己玩，目标是修改 `Sort.sort` 的代码，以便不再出现此错误消息。这有点像心理上的把戏，但许多程序员发现为自己创建这些迷你小拼图几乎让人上瘾。

In fact, this is a lot like the situation where you have an autograder for a class, and you find yourself hooked on the idea of getting the autograder to give you its love and approval. You now have the ability to create a judge for your code, whose esteem you can only win by completing the code correctly.  
事实上，这很像你有一个班级自动评分器的情况，你发现自己迷上了让自动评分器给你爱和认可的想法。您现在可以为您的代码创建一个法官，只有正确完成代码才能赢得他的尊重。

**Important note:** You may be asking "Why are you looping through the entire array? Why don't you just check if the arrays are equal using `==`? ". The reason is, when we test for equality of two objects, we cannot simply use the `==` operator. The `==` operator compares the literal bits in the memory boxes, e.g. `input == expected` would test whether or not the addresses of `input` and `expected` are the same, not whether the values in the arrays are the same. Instead, we used a loop in `testSort`, and print out the first mismatch. You could also use the built-in method `java.util.Arrays.equals` instead of a loop.  
重要说明：您可能会问“为什么要遍历整个数组？为什么不使用 `==` 检查数组是否相等？”。原因是，当我们测试两个对象是否相等时，我们不能简单地使用 `==` 运算符。 `==` 运算符比较内存盒中的文字位，例如 `input == expected` 会测试 `input` 和 `expected` 的地址是否相同，而不是数组中的值是否相同。相反，我们在 `testSort` 中使用了一个循环，并打印出第一个不匹配的地方。您还可以使用内置方法 `java.util.Arrays.equals` 而不是循环。

While the single test above wasn't a ton of work, writing a suite of such _ad hoc_ tests would be very tedious, as it would entail writing a bunch of different loops and print statements. In the next section, we'll see how the `org.junit` library saves us a lot of work.  
虽然上面的单个测试不是很多工作，但编写一套这样的临时测试会非常乏味，因为它需要编写一堆不同的循环和打印语句。在下一节中，我们将看到 `org.junit` 库如何为我们节省大量工作。

### JUnit Testing

<iframe frameborder="0" allowfullscreen="" src="//www.youtube.com/embed/NoNGCB6uJkY" data-immersive-translate-effect="1"></iframe>

The `org.junit` library provides a number of helpful methods and useful capabilities for simplifying the writing of tests. For example, we can replace our simple _ad hoc_ test from above with:  
`org.junit` 库提供了许多有用的方法和有用的功能来简化测试的编写。例如，我们可以将上面的简单临时测试替换为：

```
public static void testSort() {
    String[] input = {"i", "have", "an", "egg"};
    String[] expected = {"an", "egg", "have", "i"};
    Sort.sort(input);
    org.junit.Assert.assertArrayEquals(expected, input);
}
```

**This code is much simpler**, and does more or less the exact same thing, i.e. if the arrays are not equal, it will tell us the first mismatch. For example, if we run `testSort()` on a `Sort.sort` method that does nothing, we'd get:  
这段代码要简单得多，并且或多或少做了完全相同的事情，即如果数组不相等，它会告诉我们第一个不匹配。例如，如果我们在不执行任何操作的 `Sort.sort` 方法上运行 `testSort()` ，我们将得到：

```
Exception in thread "main" arrays first differed at element [0]; expected:<[an]> but was:<[i]>
    at org.junit.internal.ComparisonCriteria.arrayEquals(ComparisonCriteria.java:55)
    at org.junit.Assert.internalArrayEquals(Assert.java:532)
    ...
```

While this output is a little uglier than our _ad hoc_ test, we'll see at the very end of this chapter how to make it nicer.  
虽然这个输出比我们的临时测试难看一点，但我们将在本章的最后看到如何让它变得更好。

### Selection Sort

<iframe frameborder="0" allowfullscreen="" src="//www.youtube.com/embed/aYuM9VQJcUs" data-immersive-translate-effect="1"></iframe>

Before we can write a `Sort.sort` method, we need some algorithm for sorting. Perhaps the simplest sorting algorithm around is "selection sort." Selection sort consists of three steps:  
在我们编写 `Sort.sort` 方法之前，我们需要一些排序算法。也许最简单的排序算法是“选择排序”。选择排序包括三个步骤：

-   Find the smallest item. 找到最小的项目。
-   Move it to the front. 把它移到前面。
-   Selection sort the remaining N-1 items (without touching the front item).  
    选择排序剩余的 N-1 个项目（不触及前面的项目）。

For example, suppose we have the array `{6, 3, 7, 2, 8, 1}`. The smallest item in this array is `1`, so we'd move the `1` to the front. There are two natural ways to do this: One is to stick the `1` at the front and slide all the numbers over, i.e. `{1, 6, 3, 7, 2, 8}`. However, the much more efficient way is to simply swap the `1` with the old front (in this case `6`), yielding `{1, 3, 7, 2, 8, 6}`.  
例如，假设我们有数组 `{6, 3, 7, 2, 8, 1}` 。此数组中的最小项是 `1` ，因此我们将 `1` 移到前面。有两种自然的方法可以做到这一点：一种是将 `1` 放在前面并将所有数字滑过，即 `{1, 6, 3, 7, 2, 8}` 。然而，更有效的方法是简单地将 `1` 与旧的前面（在本例中为 `6` ）交换，产生 `{1, 3, 7, 2, 8, 6}` 。

We'd simply repeat the same process for the remaining digits, i.e. the smallest item in `... 3, 7, 2, 8, 6}` is `2`. Swapping to the front, we get `{1, 2, 7, 3, 8, 6}`. Repeating until we've got a sorted array, we'd get `{1, 2, 3, 7, 8, 6}`, then `{1, 2, 3, 6, 8, 7}`, then finally `{1, 2, 3, 6, 7, 8}`.  
我们只需对剩余的数字重复相同的过程，即 `... 3, 7, 2, 8, 6}` 中的最小项是 `2` 。换到前面，我们得到 `{1, 2, 7, 3, 8, 6}` 。重复直到我们得到一个排序数组，我们会得到 `{1, 2, 3, 7, 8, 6}` ，然后是 `{1, 2, 3, 6, 8, 7}` ，最后是 `{1, 2, 3, 6, 7, 8}` 。

We could mathematically prove the correctness of this sorting algorithm on any arrays by using the concept of invariants that was originally introduced in chapter 2.4, though we will not do so in this textbook. Before proceeding, try writing out your own short array of numbers and perform selection sort on it, so that you can make sure you get the idea.  
我们可以通过使用最初在 2.4 章中介绍的不变量的概念，在数学上证明这种排序算法在任何数组上的正确性，尽管我们不会在本教科书中这样做。在继续之前，尝试写出你自己的短数字数组并对它执行选择排序，这样你就可以确保你明白了。

Now that we know how selection sort works, we can write in a few short comments in our blank `Sort.sort` method to guide our thinking:  
现在我们知道选择排序是如何工作的，我们可以在空白的 `Sort.sort` 方法中写一些简短的注释来指导我们的思考：

```
public class Sort {
    /** Sorts strings destructively. */
    public static void sort(String[] x) { 
           // find the smallest item
           // move it to the front
           // selection sort the rest (using recursion?)
    }
}
```

In the following sections, I will attempt to complete an implementation of selection sort. I'll do so in a way that resembles how a student might approach the problem, so **I'll be making a few intentional errors along the way**. These intentional errors are a good thing, as they'll help demonstrate the usefulness of testing. If you spot any of the errors while reading, don't worry, we'll eventually come around and correct them.  
在接下来的章节中，我将尝试完成一个选择排序的实现。我将以类似于学生可能处理问题的方式来这样做，所以我会在这个过程中犯一些故意的错误。这些故意的错误是一件好事，因为它们将有助于证明测试的有用性。如果您在阅读时发现任何错误，请不要担心，我们最终会解决并更正它们。

### findSmallest

<iframe frameborder="0" allowfullscreen="" src="//www.youtube.com/embed/RnTUJ9lDZLw" data-immersive-translate-effect="1"></iframe>

The most natural place to start is to write a method for finding the smallest item in a list. As with `Sort.sort`, we'll start by writing a test before we even complete the method. First, we'll create a dummy `findSmallest` method that simply returns some arbitrary value:  
最自然的起点是编写一个查找列表中最小项的方法。与 `Sort.sort` 一样，我们甚至在完成该方法之前就开始编写测试。首先，我们将创建一个虚拟的 `findSmallest` 方法，它只返回一些任意值：

```
public class Sort {
    /** Sorts strings destructively. */
    public static void sort(String[] x) { 
           // find the smallest item
           // move it to the front
           // selection sort the rest (using recursion?)
    }

    /** Returns the smallest string in x. */
    public static String findSmallest(String[] x) {
        return x[2];
    }
}
```

Obviously this is not a correct implementation, but we've chosen to defer actually thinking about how `findSmallest` works until after we've written a test. Using the `org.junit` library, adding such a test to our `TestSort` class is very easy, as shown below:  
显然这不是一个正确的实现，但我们选择推迟到编写测试后才真正考虑 `findSmallest` 的工作原理。使用 `org.junit` 库，向我们的 `TestSort` 类添加这样的测试非常容易，如下所示：

```
public class TestSort {
    ...
    public static void testFindSmallest() {
        String[] input = {"i", "have", "an", "egg"};
        String expected = "an";

        String actual = Sort.findSmallest(input);
        org.junit.Assert.assertEquals(expected, actual);        
    }

    public static void main(String[] args) {
        testFindSmallest(); // note: we changed this from testSort!
    }
}
```

As with `TestSort.testsort`, we then run our `TestSort.testFindSmallest` method to make sure that it fails. When we run this test, we'll see that it actually passes, i.e. no message appears. This is because we just happened to hard code the correct return value `x[2]`. Let's modify our `findSmallest` method so that it returns something that is definitely incorrect:  
与 `TestSort.testsort` 一样，我们然后运行我们的 `TestSort.testFindSmallest` 方法以确保它失败。当我们运行这个测试时，我们会看到它实际上通过了，即没有消息出现。这是因为我们恰好硬编码了正确的返回值 `x[2]` 。让我们修改我们的 `findSmallest` 方法，让它返回一些绝对不正确的东西：

```
/** Returns the smallest string in x. */
public static String findSmallest(String[] x) {
    return x[3];
}
```

After making this change, when we run `TestSort.testFindSmallest`, we'll get an error, which is a good thing:  
进行此更改后，当我们运行 `TestSort.testFindSmallest` 时，我们会得到一个错误，这是一件好事：

```
Exception in thread "main" java.lang.AssertionError: expected:<[an]> but was:<[null]>
    at org.junit.Assert.failNotEquals(Assert.juava:834)
    at TestSort.testFindSmallest(TestSort.java:9)
    at TestSort.main(TestSort.java:24)
```

As before, we've set up for ourselves a little game to play, where our goal is now to modify the code for `Sort.findSmallest` so that this error no longer appears. This is a smaller goal than getting `Sort.sort` to work, which might be even more addictive.  
和以前一样，我们已经为自己设置了一个小游戏来玩，我们现在的目标是修改 `Sort.findSmallest` 的代码，以便不再出现此错误。这是一个比让 `Sort.sort` 工作更小的目标，后者可能更容易让人上瘾。

Side note: It might have seem rather contrived that I just happened to return the right value `x[2]`. However, when I was recording this lecture video, I actually did make this exact mistake without intending to do so!  
旁注：我只是碰巧返回了正确的值 `x[2]` ，这看起来有点做作。但是，我在录制这个讲座视频的时候，却无意中犯了这个错误！

Next we turn to actually writing `findSmallest`. This seems like it should be relatively straightforward. If you're a Java novice, you might end up writing code that looks something like this:  
接下来我们开始实际编写 `findSmallest` 。这看起来应该是相对简单的。如果您是 Java 新手，您最终可能会编写如下所示的代码：

```
/**  Returns the smallest string in x. */
public static String findSmallest(String[] x) {
    String smallest = x[0];
    for (int i = 0; i < x.length; i += 1) {
        if (x[i] < smallest) {
            smallest = x[i];
        }
    }
    return smallest;
}
```

However, this will yield the compilation error "< cannot be applied to 'java.lang.String'". The issue is that Java does not allow comparisons between Strings using the < operator.  
但是，这会产生编译错误“< cannot be applied to 'java.lang.String'”。问题是 Java 不允许使用 < 运算符比较字符串。

When you're programming and get stuck on an issue like this that is easily describable, it's probably best to turn to a search engine. For example, we might search "less than strings Java" with Google. Such a search might yield a Stack Overflow post like [this one](https://stackoverflow.com/questions/5153496/how-can-i-compare-two-strings-in-java-and-define-which-of-them-is-smaller-than-t).  
当您在编程时遇到这样一个很容易描述的问题时，最好求助于搜索引擎。例如，我们可能会用 Google 搜索“less than strings Java”。这样的搜索可能会产生像这样的 Stack Overflow 帖子。

One of the popular answers for this post explains that the `str1.compareTo(str2)` method will return a negative number if `str1 < str2`, 0 if they are equal, and a positive number if `str1 > str2`.  
这篇文章的一个流行答案解释说，如果 `str1 < str2` ， `str1.compareTo(str2)` 方法将返回一个负数，如果它们相等，则返回 0 ，如果 `str1 > str2` ，则返回一个正数。

Incorporating this into our code, we might end up with:  
将其合并到我们的代码中，我们可能会得到：

```
/** Returns the smallest string in x. 
  * @source Got help with string compares from https://goo.gl/a7yBU5. */
public static String findSmallest(String[] x) {
    String smallest = x[0];
    for (int i = 0; i < x.length; i += 1) {
        int cmp = x[i].compareTo(smallest);
        if (cmp < 0) {
            smallest = x[i];
        }
    }
    return smallest;
}
```

Note that we've used a `@source` tag in order to cite our sources. I'm showing this by example for those of you who are taking 61B as a formal course. This is not a typical real world practice.  
请注意，我们使用了 `@source` 标签来引用我们的来源。我正在通过示例向那些将 61B 作为正式课程的人展示这一点。这不是典型的现实世界实践。

Since we are using syntax features that are totally new to us, we might lack confidence in the correctness of our `findSmallest` method. Luckily, we just wrote that test a little while ago. If we try running it, we'll see that nothing gets printed, which means our code is probably correct.  
由于我们使用的语法功能对我们来说是全新的，因此我们可能对 `findSmallest` 方法的正确性缺乏信心。幸运的是，我们刚才刚刚编写了那个测试。如果我们尝试运行它，我们会看到什么也没有打印出来，这意味着我们的代码可能是正确的。

We can augment our test to increase our confidence by adding more test cases. For example, we might change `testFindSmallest` so that it reads as shown below:  
我们可以通过添加更多测试用例来增强我们的测试以增加我们的信心。例如，我们可以更改 `testFindSmallest` ，使其如下所示：

```
public static void testFindSmallest() {
    String[] input = {"i", "have", "an", "egg"};
    String expected = "an";

    String actual = Sort.findSmallest(input);
    org.junit.Assert.assertEquals(expected, actual);        

    String[] input2 = {"there", "are", "many", "pigs"};
    String expected2 = "are";

    String actual2 = Sort.findSmallest(input2);
    org.junit.Assert.assertEquals(expected2, actual2);
}
```

Rerunning the test, we see that it still passes. We are not absolutely certain that it works, but we are much more certain that we would have been without any tests.  
重新运行测试，我们看到它仍然通过。我们不能绝对确定它是否有效，但我们更确定我们会在没有任何测试的情况下使用。

### Swap

<iframe frameborder="0" allowfullscreen="" src="//www.youtube.com/embed/YjWK58NGRxw" data-immersive-translate-effect="1"></iframe>

Looking at our `sort` method below, the next helper method we need to write is something to move an item to the front, which we'll call `swap`.  
查看下面的 `sort` 方法，我们需要编写的下一个辅助方法是将项目移到前面，我们称之为 `swap` 。

```
/** Sorts strings destructively. */
public static void sort(String[] x) { 
       // find the smallest item
       // move it to the front
       // selection sort the rest (using recursion?)
}
```

Writing a `swap` method is very straightforward, and you've probably done so before. A correct implementation might look like:  
编写 `swap` 方法非常简单，您以前可能已经这样做过。正确的实现可能如下所示：

```
public static void swap(String[] x, int a, int b) {
    String temp = x[a];
    x[a] = x[b];
    x[b] = temp;
}
```

However, for the moment, let's introduce an intentional error so that we can demonstrate the utility of testing. A more naive programmer might have done something like:  
但是，目前，让我们引入一个故意的错误，以便我们可以展示测试的实用性。一个更天真的程序员可能会做这样的事情：

```
public static void swap(String[] x, int a, int b) {    
    x[a] = x[b];
    x[b] = x[a];
}
```

Writing a test for this method is quite easy with the help of JUnit. An example test is shown below. Note that we have also edited the main method so that it calls `testSwap` instead of `testFindSmallest` or `testSort`.  
在 JUnit 的帮助下，为该方法编写测试非常容易。示例测试如下所示。请注意，我们还编辑了 main 方法，以便它调用 `testSwap` 而不是 `testFindSmallest` 或 `testSort` 。

```
public class TestSort {
    ...    

    /** Test the Sort.swap method. */
    public static void testSwap() {
        String[] input = {"i", "have", "an", "egg"};
        int a = 0;
        int b = 2;
        String[] expected = {"an", "have", "i", "egg"};

        Sort.swap(input, a, b);
        org.junit.Assert.assertArrayEquals(expected, input);
    }

    public static void main(String[] args) {
        testSwap();
    }
}
```

Running this test on our buggy `swap` yields an error, as we'd expect.  
正如我们所料，在我们的越野车 `swap` 上运行此测试会产生错误。

```
Exception in thread "main" arrays first differed in element [2]; expected:<[i]> but was:<[an]>
    at TestSort.testSwap(TestSort.java:36)
```

It's worth briefly noting that it is important that we call only `testSwap` and not `testSort` as well. For example, if our `main` method was as below, the entire `main` method will terminate execution as soon as `testSort` fails, and `testSwap` will never run:  
值得注意的是，我们只调用 `testSwap` 而不是 `testSort` 是很重要的。例如，如果我们的 `main` 方法如下所示，一旦 `testSort` 失败，整个 `main` 方法将终止执行，而 `testSwap` 将永远不会运行：

```
public static void main(String[] args) {
    testSort();
    testFindSmallest();
    testSwap();
}
```

We will learn a more elegant way to deal with multiple tests at the end of this chapter that will avoid the need to manually specify which tests to run.  
我们将在本章末尾学习一种更优雅的方法来处理多个测试，这将避免手动指定要运行的测试的需要。

Now that we have a failing test, we can use it to help us debug. One way to do this is to set a breakpoint inside the `swap` method and use the visual debugging feature in IntelliJ. If you would like more information about and practice on debugging, check out [Lab3](https://sp19.datastructur.es/materials/lab/lab3/lab3). Stepping through the code line-by-line makes it immediately clear what is wrong (see video or try it yourself), and we can fix it by updating our code to include a temporary variable as that the beginning of this section:  
现在我们有一个失败的测试，我们可以用它来帮助我们调试。一种方法是在 `swap` 方法内设置断点并使用 IntelliJ 中的可视化调试功能。如果您想了解有关调试的更多信息和练习，请查看 Lab3。逐行执行代码可以立即清楚哪里出了问题（观看视频或自己尝试），我们可以通过更新我们的代码以包含一个临时变量来修复它，如本节开头所示：

```
public static void swap(String[] x, int a, int b) {
    String temp = x[a];
    x[a] = x[b];
    x[b] = temp;
}
```

Rerunning the test, we see that it now passes.  
重新运行测试，我们看到它现在通过了。

### Revising findSmallest 修改 findSmallest

<iframe frameborder="0" allowfullscreen="" src="//www.youtube.com/embed/opqj7VyUDR8" data-immersive-translate-effect="1"></iframe>

Now that we have multiple pieces of our method done, we can start trying to connect them up together to create a `Sort` method.  
现在我们已经完成了方法的多个部分，我们可以开始尝试将它们连接在一起以创建一个 `Sort` 方法。

```
/** Sorts strings destructively. */
public static void sort(String[] x) { 
       // find the smallest item
       // move it to the front
       // selection sort the rest (using recursion?)
}
```

It's clear how to use our `findSmallest` and `swap` methods, but when we do so, we immediately realize there is a bit of a mismatch: `findSmallest` returns a `String`, and `swap` expects two indices.  
很清楚如何使用我们的 `findSmallest` 和 `swap` 方法，但是当我们这样做时，我们立即意识到有一点不匹配： `findSmallest` 返回一个 `String` ，而 `swap` 需要两个索引。

```
/** Sorts strings destructively. */
public static void sort(String[] x) { 
       // find the smallest item
       String smallest = findSmallest(x);

       // move it to the front
       swap(x, 0, smallest);

       // selection sort the rest (using recursion?)
}
```

In other words, what `findSmallest` should have been returning is the index of the smallest String, not the String itself. Making silly errors like this is normal and really easy to do, so don't sweat it if you find yourself doing something similar. Iterating on a design is part of the process of writing code.  
换句话说， `findSmallest` 应该返回的是最小字符串的索引，而不是字符串本身。犯这样的愚蠢错误很正常，而且很容易犯，所以如果您发现自己在做类似的事情，请不要担心。迭代设计是编写代码过程的一部分。

Luckily, this new design can be easily changed. We simply need to adjust `findSmallest` to return an `int`, as shown below:  
幸运的是，这个新设计可以很容易地改变。我们只需要调整 `findSmallest` 以返回 `int` ，如下所示：

```
public static int findSmallest(String[] x) {
    int smallestIndex = 0;
    for (int i = 0; i < x.length; i += 1) {
        int cmp = x[i].compareTo(x[smallestIndex]);
        if (cmp < 0) {
            smallestIndex = i;
        }
    }
    return smallestIndex;
}
```

Since this is a non-trivial change, we should also update `testFindSmallest` and make sure that `findSmallest` still works.  
由于这是一个重要的更改，我们还应该更新 `testFindSmallest` 并确保 `findSmallest` 仍然有效。

```
public static void testFindSmallest() {
    String[] input = {"i", "have", "an", "egg"};
    int expected = 2;

    int actual = Sort.findSmallest(input);
    org.junit.Assert.assertEquals(expected, actual);        

    String[] input2 = {"there", "are", "many", "pigs"};
    int expected2 = 1;

    int actual2 = Sort.findSmallest(input);
    org.junit.Assert.assertEquals(expected2, actual2);
}
```

After modifying `TestSort` so that this test is run, and running `TestSort.main`, we see that our code passes the tests. Now, revising sort, we can fill in the first two steps of our sorting algorithm.  
在修改 `TestSort` 以便运行该测试并运行 `TestSort.main` 之后，我们看到我们的代码通过了测试。现在，修改排序，我们可以填写排序算法的前两个步骤。

```
/** Sorts strings destructively. */
public static void sort(String[] x) { 
   // find the smallest item
   // move it to the front
   // selection sort the rest (using recursion?)
   int smallestIndex = findSmallest(x);
   swap(x, 0, smallestIndex);
}
```

All that's left is to somehow selection sort the remaining items, perhaps using recursion. We'll tackle this in the next section.  
剩下的就是以某种方式对剩余的项目进行选择排序，也许使用递归。我们将在下一节中解决这个问题。

Reflecting on what we've accomplished, it's worth noting how we created tests first, and used these to build confidence that the actual methods work before we ever tried to use them for anything. This is an incredibly important idea, and one that will serve you well if you decide to adopt it.  
回顾我们所取得的成就，值得注意的是我们如何首先创建测试，并在我们尝试将它们用于任何事情之前使用这些来建立对实际方法有效的信心。这是一个非常重要的想法，如果您决定采用它，它将对您大有裨益。

### Recursive Helper Methods 递归辅助方法

<iframe frameborder="0" allowfullscreen="" src="//www.youtube.com/embed/YcYUYZc-lOM" data-immersive-translate-effect="1"></iframe>

To begin this section, consider how you might make the recursive call needed to complete `sort`:  
在开始本节之前，请考虑如何进行完成 `sort` 所需的递归调用：

```
/** Sorts strings destructively. */
public static void sort(String[] x) { 
   int smallestIndex = findSmallest(x);
   swap(x, 0, smallestIndex);
   // recursive call??
}
```

For those of you who are used to a language like Python, it might be tempting to try and use something like slice notation, e.g.  
对于那些习惯了像 Python 这样的语言的人来说，尝试使用像切片符号这样的东西可能很诱人，例如

```
/** Sorts strings destructively. */
public static void sort(String[] x) { 
   int smallestIndex = findSmallest(x);
   swap(x, 0, smallestIndex);
   sort(x[1:])
}
```

However, there is no such thing in Java as a reference to a sub-array, i.e. we can't just pass the address of the next item in the array.  
但是，在 Java 中没有子数组引用这样的东西，即我们不能只传递数组中下一项的地址。

This problem of needing to consider only a subset of a larger array is very common. A typical solution is to create a private helper method that has an additional parameter (or parameters) that delineate which part of the array to consider. For example, we might write a private helper method also called `sort` that consider only the items starting with item `start`.  
这种只需要考虑较大数组的一个子集的问题很常见。一个典型的解决方案是创建一个私有辅助方法，该方法具有一个（或多个）附加参数，用于描述要考虑数组的哪一部分。例如，我们可以编写一个也称为 `sort` 的私有辅助方法，它只考虑以项目 `start` 开头的项目。

```
/** Sorts strings destructively starting from item start. */
private static void sort(String[] x, int start) { 
    // TODO
}
```

Unlike our public sort method, it's relatively straightforward to use recursion now that we have the additional parameter `start`, as shown below. We'll test this method in the next section.  
与我们的公共排序方法不同，现在我们有了额外的参数 `start` ，使用递归就相对简单了，如下所示。我们将在下一节中测试此方法。

```
/** Sorts strings destructively starting from item start. */
private static void sort(String[] x, int start) { 
   int smallestIndex = findSmallest(x);
   swap(x, start, smallestIndex);
   sort(x, start + 1);
}
```

Now that we have a helper method, we need to set up the correct original call. If we set the start to 0, we effectively sort the entire array.  
现在我们有了辅助方法，我们需要设置正确的原始调用。如果我们将开始设置为 0，我们将有效地对整个数组进行排序。

```
/** Sorts strings destructively. */
public static void sort(String[] x) { 
   sort(x, 0);
}
```

This approach is quite common when trying to use recursion on a data structure that is not inherently recursive, e.g. arrays.  
当尝试在本质上不是递归的数据结构上使用递归时，这种方法很常见，例如阵列。

### Debugging and Completing Sort 调试和完成排序

<iframe frameborder="0" allowfullscreen="" src="//www.youtube.com/embed/ciP4dSH_CHA" data-immersive-translate-effect="1"></iframe>

Running our `testSort` method, we immediately run into a problem:  
运行我们的 `testSort` 方法，我们立即遇到了一个问题：

```
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: 4
    at Sort.swap(Sort.java:16)
```

Using the Java debugger, we see that the problem is that somehow `start` is reaching the value 4. Stepping through the code carefully (see video above), we find that the issue is that we forgot to include a base case in our recursive `sort` method. Fixing this is straightforward:  
使用 Java 调试器，我们看到问题是 `start` 以某种方式达到了值 4。仔细查看代码（参见上面的视频），我们发现问题是我们忘记在递归中包含一个基本情况 `sort` 方法。解决这个问题很简单：

```
/** Sorts strings destructively starting from item start. */
private static void sort(String[] x, int start) { 
   if (start == x.length) {
       return;
   }
   int smallestIndex = findSmallest(x);
   swap(x, start, smallestIndex);
   sort(x, start + 1);
}
```

Rerunning this test again, we get another error:  
再次重新运行这个测试，我们得到另一个错误：

```
Exception in thread "main" arrays first differed at element [0]; 
   expected<[an]> bit was:<[have]>
```

Again, with judicious use of the IntelliJ debugger (see video), we can identify a line of code whose result does not match our expectations. Of note is the fact that I debugged the code at a higher level of abstraction than you might have otherwise, which I achieve by using `Step Over` more than `Step Into`. As discussed in lab 3, debugging at a higher level of abstraction saves you a lot of time and energy, by allowing you to compare the results of entire function calls with your expectation.  
同样，通过明智地使用 IntelliJ 调试器（参见视频），我们可以识别出一行代码，其结果与我们的预期不符。值得注意的是，我在比其他方式更高的抽象级别调试代码，这是通过使用 `Step Over` 而不是 `Step Into` 来实现的。正如实验 3 中所讨论的，在更高的抽象层次上进行调试可以让您将整个函数调用的结果与您的预期进行比较，从而为您节省大量时间和精力。

Specifically, we find that when sorting the last 3 (out of 4) items, the `findSmallest` method is giving as the 0th item (`"an"`) rather than the 3rd item (`"egg"`) when called on the input `{"an", "have", "i", "egg"}`. Looking carefully at the definition of `findSmallest`, this behavior is not a surprise, since `findSmallest` looks at the entire array, not just the items starting from position `start`. This sort of design flaw is very common, and writing tests and using the debugger is a great way to go about fixing them.  
具体来说，我们发现在对最后 3 个（共 4 个）项目进行排序时， `findSmallest` 方法在输入 @3 上调用时给出第 0 个项目（ `"an"` ）而不是第 3 个项目（ `"egg"` ） # 。仔细查看 `findSmallest` 的定义，这种行为并不奇怪，因为 `findSmallest` 查看整个数组，而不仅仅是从位置 `start` 开始的项目。这种设计缺陷很常见，编写测试和使用调试器是修复它们的好方法。

To fix our code, we revise `findSmallest` so that it takes a second parameter `start`, i.e. `findSmallest(String[] x, int start)`. In this way, we ensure that we're finding the smallest item only out of the last however many are still unsorted. The revision is as shown below:  
为了修复我们的代码，我们修改了 `findSmallest` ，让它接受第二个参数 `start` ，即 `findSmallest(String[] x, int start)` 。通过这种方式，我们确保我们只从最后一个项目中找到最小的项目，但许多项目仍未排序。修改如下图：

```
public static int findSmallest(String[] x, int start) {
    int smallestIndex = start;
    for (int i = start; i < x.length; i += 1) {
        int cmp = x[i].compareTo(x[smallestIndex]);
        if (cmp < 0) {
            smallestIndex = i;
        }
    }
    return smallestIndex;
}
```

Given that we've made a significant change to one of our building blocks, i.e. `findSmallest`, we should ensure that our changes are correct.  
鉴于我们已经对我们的构建块之一进行了重大更改，即 `findSmallest` ，我们应该确保我们的更改是正确的。

We first modify `testFindSmallest` so that it uses our new parameter, as shown below:  
我们首先修改 `testFindSmallest` ，让它使用我们的新参数，如下图：

```
public static void testFindSmallest() {
    String[] input = {"i", "have", "an", "egg"};
    int expected = 2;

    int actual = Sort.findSmallest(input, 0);
    org.junit.Assert.assertEquals(expected, actual);        

    String[] input2 = {"there", "are", "many", "pigs"};
    int expected2 = 2;

    int actual2 = Sort.findSmallest(input2, 2);
    org.junit.Assert.assertEquals(expected2, actual2);
}
```

We then modify `TestSort.main` so that it runs `testFindSmallest`. This test passes, strongly suggesting that our revisions to `findSmallest` were correct.  
然后我们修改 `TestSort.main` 使其运行 `testFindSmallest` 。该测试通过，强烈表明我们对 `findSmallest` 的修改是正确的。

We next modify `Sort.sort` so that it uses the new `start` parameter in `findSmallest`:  
接下来我们修改 `Sort.sort` ，使其在 `findSmallest` 中使用新的 `start` 参数：

```
/** Sorts strings destructively starting from item start. */
private static void sort(String[] x, int start) { 
   if (start == x.length) {
       return;
   }
   int smallestIndex = findSmallest(x, start);
   swap(x, start, smallestIndex);
   sort(x, start + 1);
}
```

We then modify `TestSort` so that it runs `TestSort.sort` and voila, the method works. We are done! You have now seen the "new way" from the beginning of this lecture, which we'll reflect on for the remainder of this chapter.  
然后我们修改 `TestSort` 使其运行 `TestSort.sort` 瞧，这个方法起作用了。我们完了！您现在已经了解了本讲座开头的“新方法”，我们将在本章的剩余部分对此进行反思。

### Reflections on the Development Process  
开发过程的思考

<iframe frameborder="0" allowfullscreen="" src="//www.youtube.com/embed/CbULOb4UBMY" data-immersive-translate-effect="1"></iframe>

When you're writing and debugging a program, you'll often find yourself switching between different contexts. Trying to hold too much in your brain at once is a recipe for disaster at worst, and slow progress at best.  
在编写和调试程序时，您经常会发现自己在不同的上下文之间切换。试图一次在大脑中容纳太多东西，最坏的情况下是灾难的根源，最好的情况下也是缓慢的进展。

Having a set of automated tests helps reduce this cognitive load. For example, we were in the middle of writing `sort` when we realized there was a bug in `findSmallest`. We were able to switch contexts to consider `findSmallest` and establish that it was correct using our `testFindSmallest` method, and then switch back to `sort`. This is in sharp contrast to a more naive approach where you would simply be calling `sort` over and over and trying to figure out if the behavior of the overall algorithm suggests that the `findSmallest` method is correct.  
拥有一组自动化测试有助于减少这种认知负担。例如，当我们意识到 `findSmallest` 中存在错误时，我们正在编写 `sort` 。我们能够切换上下文以考虑 `findSmallest` 并使用我们的 `testFindSmallest` 方法确定它是正确的，然后切换回 `sort` 。这与一种更天真的方法形成鲜明对比，在这种方法中，您只需一遍又一遍地调用 `sort` 并试图弄清楚整个算法的行为是否表明 `findSmallest` 方法是正确的。

As an analogy, you could test that a parachute's ripcord works by getting in an airplane, taking off, jumping out, and pulling the ripcord and seeing if the parachute comes out. However, you could also just pull it on the ground and see what happens. So, too, is it unnecessary to use `sort` to try out `findSmallest`.  
打个比方，您可以通过进入飞机、起飞、跳出、拉动拉索并查看降落伞是否弹出来测试降落伞的拉索是否正常工作。但是，您也可以将它拉到地上，看看会发生什么。那么，也没有必要使用 `sort` 来尝试 `findSmallest` 。

As mentioned earlier in this chapter, tests also allow you to gain confidence in the basic pieces of your program, so that if something goes wrong, you have a better idea of where to start looking.  
正如本章前面提到的，测试还可以让您对程序的基本部分更有信心，这样如果出现问题，您可以更好地了解从哪里开始查找。

Lastly, tests make it easier to refactor your code. Suppose you decide to rewrite `findSmallest` so that it is faster or more readable. We can safely do so by making our desired changes and seeing if the tests still work.  
最后，测试使重构代码变得更容易。假设您决定重写 `findSmallest` 以使其更快或更具可读性。我们可以通过进行所需的更改并查看测试是否仍然有效来安全地这样做。

### Better JUnit

<iframe frameborder="0" allowfullscreen="" src="//www.youtube.com/embed/hm5_pYuw-Dk" data-immersive-translate-effect="1"></iframe>

First, let's reflect on the new syntax we've seen today, namely `org.junit.Assert.assertEquals(expected, actual)`. This method (with a very long name) tests that `expected` and `actual` are equal, and if they are not, terminates the program with a verbose error message.  
首先，让我们回顾一下我们今天看到的新语法，即 `org.junit.Assert.assertEquals(expected, actual)` 。此方法（名称很长）测试 `expected` 和 `actual` 是否相等，如果不相等，则终止程序并显示详细的错误消息。

JUnit has many more such methods other than `assertEquals`, such as `assertFalse`, `assertNotNull`, `fail`, and so forth, and they can be found in the official [JUnit documentation](http://junit.org/junit4/javadoc/4.12/org/junit/Assert.html). JUnit also has many other complex features we will not describe or teach in 61B, though you're free to use them.  
除了 `assertEquals` ，JUnit还有很多这样的方法，比如 `assertFalse` 、 `assertNotNull` 、 `fail` 等等，可以在JUnit官方文档中找到。 JUnit 还有许多我们不会在 61B 中描述或教授的其他复杂特性，尽管您可以自由使用它们。

While JUnit certainly improved things, our test code from before was a bit clumsy in several ways. In the remainder of this section, we'll talk about two major enhancements you can make so that your code is cleaner and easier to use. These enhancements will seem very mysterious from a syntax point of view, so just copy what we're doing for now, and we'll explain some (but not all) of it in a later chapter.  
虽然 JUnit 确实改进了一些东西，但我们之前的测试代码在几个方面有点笨拙。在本节的其余部分，我们将讨论您可以进行的两项主要增强，以使您的代码更简洁、更易于使用。从语法的角度来看，这些增强功能看起来非常神秘，所以只需复制我们现在所做的，我们将在后面的章节中解释其中的一些（但不是全部）。

The first enhancement is to use what is known as a "test annotation". To do this, we:  
第一个增强是使用所谓的“测试注释”。为此，我们：

-   Precede each method with `@org.junit.Test` (no semi-colon).  
    在每个方法前加上 `@org.junit.Test` （无分号）。
-   Change each test method to be non-static.  
    将每个测试方法更改为非静态的。
-   Remove our `main` method from the `TestSort` class.  
    从 `TestSort` 类中删除我们的 `main` 方法。

Once we've done these three things, if we re-run our code in JUnit using the Run->Run command, all of the tests execute without having to be manually invoked. This annotation based approach has several advantages:  
一旦我们完成了这三件事，如果我们使用 Run->Run 命令在 JUnit 中重新运行我们的代码，所有测试都会执行，而无需手动调用。这种基于注释的方法有几个优点：

-   No need to manually invoke tests.  
    无需手动调用测试。
-   All tests are run, not just the ones we specify.  
    运行所有测试，而不仅仅是我们指定的测试。
-   If one test fails, the others still run.  
    如果一个测试失败，其他测试仍然运行。
-   A count of how many tests were run and how many passed is provided.  
    提供了运行了多少测试以及通过了多少测试的计数。
-   The error messages on a test failure are much nicer looking.  
    测试失败时的错误消息看起来更漂亮。
-   If all tests pass, we get a nice message and a green bar appears, rather than simply getting no output.  
    如果所有测试都通过，我们会收到一条好消息并出现一个绿色条，而不是简单地没有输出。

The second enhancement will let us use shorter names for some of the very lengthy method names, as well as the annotation name. Specifically, we'll use what is known as an "import statement".  
第二个增强功能将允许我们对一些非常冗长的方法名称以及注释名称使用较短的名称。具体来说，我们将使用所谓的“导入语句”。

We first add the import statement `import org.junit.Test;` to the top of our file. After doing this, we can replace all instances of `@org.junit.Test` with simply `@Test`.  
我们首先将导入语句 `import org.junit.Test;` 添加到我们文件的顶部。这样做之后，我们可以用简单的 `@Test` 替换所有 `@org.junit.Test` 实例。

We then add our second import statement `import static org.junit.Assert.*`. After doing this, anywhere we can omit anywhere we had `org.junit.Assert.`. For example, we can replace `org.junit.Assert.assertEquals(expected2, actual2);` with simply `assertEquals(expected2, actual2);`  
然后我们添加第二个导入语句 `import static org.junit.Assert.*` 。这样做之后，我们可以在任何地方省略我们有 `org.junit.Assert.` 的任何地方。例如，我们可以将 `org.junit.Assert.assertEquals(expected2, actual2);` 替换为简单的 `assertEquals(expected2, actual2);`

We will explain exactly why import statements are in a later lecture. For now, just use and enjoy.  
我们将在稍后的讲座中准确解释为什么要使用 import 语句。现在，只需使用并享受。

### Testing Philosophy 测试理念

<iframe frameborder="0" allowfullscreen="" src="//www.youtube.com/embed/pfGYUHUbfxA" data-immersive-translate-effect="1"></iframe>

##### Correctness Tool #1: Autograder 正确性工具 #1：Autograder

Let's go back to ground zero. The autograder was likely the first correctness tool you were exposed to. Our autograder is in fact based on JUnit plus some extra custom libraries.  
让我们回到零基础。 autograder 可能是您接触到的第一个正确性工具。我们的自动分级器实际上是基于 JUnit 加上一些额外的自定义库。

There are some great benefits to autograders. Perhaps most importantly, it verifies correctness for you, saving you from the tedious and non-instructive task of writing all of your own tests. It also gamifies the assessment process by providing juicy points as an incentive to acheiving correctness. This can also backfire if students spend undue amounts of time chasing final points that won't actually affect their grade or learning.  
自动评分器有一些很大的好处。也许最重要的是，它会为您验证正确性，使您免于编写所有自己的测试的繁琐且无指导意义的任务。它还通过提供多汁点作为实现正确性的激励来游戏化评估过程。如果学生花费过多的时间追求实际上不会影响他们的成绩或学习的最终分数，这也会适得其反。

However, autograders don't exist in the real world and relying on autograders can build bad habits. One's workflow is hindered by sporadically uploading your code and waiting for the autograder to run. _Autograder Driven Development_ is an extreme version of this in which students write all their code, fix their compiler errors, and then submit to the autograder. After getting back errors, students may try to make some changes, sprinkle in print statements, and submit again. And repeat. Ultimately, you are not in control of either your workflow or your code if you rely on an autograder.  
然而，自动评分器在现实世界中并不存在，依赖自动评分器会养成坏习惯。偶尔上传您的代码并等待自动评分器运行会阻碍您的工作流程。 Autograder Driven Development 是一个极端的版本，学生编写所有代码，修复编译器错误，然后提交给 autograder。返回错误后，学生可以尝试进行一些更改，打印语句，然后再次提交。并重复。最终，如果您依赖自动评分器，您将无法控制您的工作流程或代码。

##### Correctness Tool #2: JUnit Tests 正确性工具 #2：JUnit 测试

JUnit testing, as we have seen, unlocks a new world for you. Rather than relying on an autograder written by someone else, you write tests for each piece of your program. We refer to each of these pieces as a unit. This allows you to have confidence in each unit of your code - you can depend on them. This also helps decrease debugging time as you can isolate attention to one unit of code at a time (often a single method). Unit testing also forces you to clarify what each unit of code should be accomplishing.  
正如我们所见，JUnit 测试为您开启了一个新世界。您不必依赖别人编写的自动评分器，而是为程序的每一部分编写测试。我们将这些片段中的每一个都称为一个单元。这使您对代码的每个单元都充满信心——您可以依赖它们。这也有助于减少调试时间，因为您可以一次将注意力集中在一个代码单元（通常是一个方法）上。单元测试还迫使您弄清楚每个代码单元应该完成什么。

There are some downsides to unit tests, however. First, writing thorough tests takes time. It's easy to write incomplete unit tests which give a false confidence to your code. It's also difficult to write tests for units that depend on other units (consider the `addFirst` method in your `LinkedListDeque`).  
然而，单元测试也有一些缺点。首先，编写全面的测试需要时间。很容易编写不完整的单元测试，这会给您的代码带来错误的信心。为依赖于其他单元的单元编写测试也很困难（考虑 `LinkedListDeque` 中的 `addFirst` 方法）。

**_Test-Driven Development (TDD) 测试驱动开发 (TDD)_**

TDD is a development process in which we write tests for code before writing the code itself. The steps are as follows:  
TDD 是一个开发过程，我们在编写代码本身之前先为代码编写测试。步骤如下：

1.  Identify a new feature.  确定一个新特征。
2.  Write a unit test for that feature.  
    为该功能编写单元测试。
3.  Run the test. It should fail.  
    运行测试。它应该失败。
4.  Write code that passes the test. Yay!  
    编写通过测试的代码。耶！
5.  Optional: refactor code to make it faster, cleaner, etc. Except now we have a reference to tests that should pass.  
    可选：重构代码以使其更快、更清洁等。除了现在我们有一个应该通过的测试的参考。

Test-Driven Development is not required in this class and may not be your style but unit testing in general is most definitely a good idea.  
测试驱动开发在这门课中不是必需的，可能不是你的风格，但一般来说单元测试绝对是个好主意。

##### Correctness Tool #3: Integration Testing  
正确性工具 #3：集成测试

Unit tests are great but we should also make sure these units work properly together ([unlike this meme](https://media.giphy.com/media/3o7rbPDRHIHwbmcOBy/giphy.gif)). Integration testing verifies that components interact properly together. JUnit can in fact be used for this. You can imagine unit testing as the most nitty gritty, with integration testing a level of abstraction above this.  
单元测试很棒，但我们还应该确保这些单元一起正常工作（不像这个模因）。集成测试验证组件是否正确交互。 JUnit 实际上可以用于此。您可以将单元测试想象成最具体的部分，集成测试的抽象级别高于此。

The challenge with integration testing is that it is tedious to do manually yet challenging to automate. And at a high level of abstraction, it's easy to miss subtle or rare errors.  
集成测试的挑战在于，手动执行起来很乏味，而自动化则具有挑战性。在较高的抽象层次上，很容易遗漏细微或罕见的错误。

As a summary, you should **definitely write tests but only when they might be useful!** Taking inspiration from TDD, writing your tests before writing code can also be very helpful in some cases.  
总而言之，您绝对应该编写测试，但只有在它们可能有用的时候！从 TDD 中汲取灵感，在编写代码之前编写测试在某些情况下也非常有帮助。

### What's next?

-   [Project 1b](https://sp19.datastructur.es/materials/proj/proj1b/proj1b)